\section{Spieleentwicklung für Ludimus}
\subsection{Grundgedanke}
Eine Kernidee bei der Entstehung von Ludimus war schon immer, dass auch andere Entwickler für Ludimus Spiele entwickeln. Da Ludimus eine Spieleplattform ist, benötigt sie viele Spiele, um genügend Abwechslung zu bieten. Diese im benötigten Ausmaß alleine zu entwickeln, ist nahezu unmöglich, deshalb sollten Entwickler, die C\# beherrschen, mit Hilfe unserer Dokumentation eigenständig Spiele entwickeln können, welche wir nach einem Qualitätscheck dann in unsere Plattform aufnehmen.
Aus diesem Grund haben wir Ludimus so “offen” wie nur möglich programmiert. Entwicklern soll das Maximum an Schnittstellen angeboten werden, damit diese so kreativ wie möglich werden können. Ungeachtet dessen wird unsererseits auf Qualität geachtet, da nicht jedes Spiel auf unserer Plattform erwünscht ist. Die Hauptzielgruppe von Ludimus sind Familien und ein Kernpunkt der Entwicklung der Spiele ist deshalb, dass diese für Kinder geeignet sind.
\subsection{Motivation}
Warum soll jemand ein Spiel für eine fremde Plattform entwickeln? Als Motivation für Entwickler dient zum einen das Gefühl, dass eventuell hunderte bis tausende Familien ihr Spiel spielen und damit Spaß haben, andererseits aber auch Geld. Jeder Programmierer, der sein Werk auf unserer Plattform veröffentlicht, kann damit Geld verdienen, jedoch gibt es keine feste Bezahlung. Den Entwicklern stehen 30\% des gesamten Gewinns zur verfügung. Je nachdem wie oft sein Spiel gespielt wird bekommt ein Entwickler Prozente von diesem Pool. Das heißt ein Entwickler welcher bereits 5 Spiele programmiert hat und diese alle sehr oft gespielt werden bekommt zum Beispiel von diesem 30\% Pool wiederum 14\%. Ein Programmierer der jedoch nur ein Spiel entwickelt hat und dieses wird nicht so oft gespielt erhält von den 30\% nur 1,2\%. Somit können Entwickler welche viele und gute Spiele programmieren mit Ludimus Geld verdienen und haben mehr Ansporn immer neue Spiele zu liefern. 
\subsection{Wie programmiere ich Spiele für Ludimus}
Wer sich dazu entschließt, Spiele für Ludimus zu entwickeln, benötigt Kenntnisse in C\# und Unity, da Ludimus darauf aufbaut. Um ein Spiel zu erstellen, benötigt man zwei Unityscenes. Eine für alles was am Server angezeigt wird und eine zweite für die Steuerung am Handy. Nun gibt es 3 wichtige Klassen, welche der Programmierer wissen muss, um die Ludimusschnittstellen nutzen zu können. Dies sind der Playermanager, der Player für den Server und der ClientController für das Smartphone.
Die einzelnen Klassen werden bereits im Abschnitt “Für Verbindung wichtige Klassen und Methoden / Schnittstellen” \ref{fvwkum} behandelt. Es werden alle Methoden aufgezeigt, welche ein Entwickler zur Verfügung hat und auch alle Delegates, auf welche sich der Programmierer subscriben und somit dem Player eigene Methoden zuweisen kann. Am wichtigsten hierbei sind der InputHandler der Player Klasse und der InputHandler des ClientControllers. Diese werden aufgerufen, wenn der jeweils andere, per Network Stream, ein Key-Value Pair schickt und es noch keine vordefinierte Funktion dafür gibt. Die vordefinierten Keys sind unter der jeweiligen “Übersicht der Verbindung“ zu finden.
\subsection{Testen}
Zum Testen der Spiele für Ludimus gibt es einen eigenen Debugmodus. (Siehe \ref{sec:debug-modus})
\section{Vorgang Spieleauswahl}
Bei der Spieleauswahl für Ludimus ging es zunächst um Spiele, die jeder kennt, wie zum Beispiel Poker, welches auch für den Proof of Concept benutzt wurde. Ludimus war am Anfang eine Plattform für Brett,- Karten- und Arcadespiele. Mit der Zeit distanzierten wir uns von der Idee der Kartenspiele auf Ludimus immer mehr, da einer der Hauptzwecke von Ludimus ist, viele Spiele für unterwegs mitnehmen zu können und dies bei Kartenspielen nicht notwendig erscheint. Kartenspiele sind meist klein und handlich und man kann mit einem einfachen Pokerkartenset schon sehr viele verschiedene Spiele spielen. Dazu benötigt man keine eigene Plattform. Für Spiele jedoch die viel Platz im Koffer brauchen und zusätzlich noch teuer sind, macht es Sinn sie zu digitalisieren und alle auf einer Plattform zu vereinen. Sinnvoll ist die Plattform auch für Spiele, welche ohnehin nur digital spielbar sind oder um eine eigene Spiel-Idee zu realisieren. Also soll Ludimus mehr eine Brett- und Arcade-Spielesammlung sein? Nein. Im Laufe der Zeit änderte sich der Fokus von der Zielgruppe “Alle” auf die Zielgruppe Familie. Dies hatte zur Folge, dass wir nicht mehr Spiele bereitstellen wollten, die jeder kennt, sondern die Kindern und Eltern Spaß machen. Auch wurde uns klar, dass Kinder eher Arcadespiele, welche schnell und einfach zu verstehen sind, spielen, als langwierige Brettspiele mit einer langen Anleitung. Zusätzlich weichen unsere Milestones von den tatsächlichen Spielen weit ab, in der Anzahl und in der Art. Die Anpassungen in Bezug auf die Art der Spiele wurde bereits erklärt. Warum sich auch die Anzahl veränderte, hat einen einfachen Grund: Qualität. Eine Plattform, welche sich an Eltern und Kinder richtet, muss qualitativ besonders hochwertig sein und auch die Spiele müssen poliert sein. Die Plattform selbst wurde zwei mal neu geschrieben, da wir mit der Qualität der jeweiligen Vorgägnerversion nicht zufrieden waren, sie zu wenig Schnittstellen hatten oder eine andere Technologie verwendet wurde. Auch bei den Spielen wurde auf Qualität und nicht auf Quantität gesetzt, so wurden aus den zehn angestrebten Spiele vier Spiele, welche sich jedoch gut spielen lassen und keine Fehler aufweisen.
\section{Probleme bei der Spieleentwicklung}
Bei der Entwicklung der Spiele stießen wir auf viele Hindernisse, welche meistens nur das jeweilige Spiel beeinflussen und deshalb erst später aufgelistet werden. Es gab jedoch auch Probleme, welche alle Spiele betreffen, zum Beispiel wie die Spiele zur Runtime geladen werden oder wie die Spiele Zugriff auf die Player Objekte erhalten. Für all diese Schwierigkeiten fanden sich relativ einfache Lösungen, nur für eine nicht: Ludimus auf dem Tablet! Wie soll das Tablet die Rechenleistung eines Laptops/PCs schaffen? Es gibt dabei vor allem zwei große Teilprobleme.
\newline \newline \tab 
- Erstens: Spiele, welche optisch ansprechen brauchen viel Rechenleistung. Rechenleistung, die ein Tablet nicht zur Verfügung hat. Hierfür gibt es zwei Lösungsansätze und keiner davon ist im Grunde perfekt. Aber zunächst: Warum soll das Spiel schön aussehen? Kinder und Eltern werden lieber etwas spielen, das auf sie optisch einen guten Eindruck macht, da es von Qualität zeugt, wenn kein Pixelmatsch auf dem Bildschirm ist. Auch macht es einfach mehr Spaß, wenn die Kinder erkennen können, was genau sie jetzt im Spiel machen und nicht raten müssen, was diese Pixel überhaupt darstellen sollen. Lösungsansätze:
\newline \newline \tab \tab 
+ Lösungsansatz 1: Bestimmte Spiele werden einfach nur auf dem PC/Laptop angeboten und sind auf dem Tablet nicht verfügbar, Problem gelöst. Nachteil: Dem zahlenden User wird die Anzahl der Spiele eingeschränkt, nur weil er zum Beispiel im Urlaub keinen PC zur Verfügung hat. Natürlich hat der User zwar die Möglichkeit, einfache Spiele zu spielen, diese gefallen den Kindern meistens aber nicht so gut, wie die grafisch anspruchsvollen Spiele. Zum Beispiel gefällt den meisten Kindern ein grafisch heraus geputztes Geschicklichkeitsspiel mehr als eine Runde Poker.
\newline \newline \tab \tab 
+ Lösungsansatz 2: Man kann die Spiele grafisch für das Tablet downgraden. Dies erfordert viel Zeit, die wir nicht zur Verfügung haben. Auch besteht die Gefahr, dass ein Pixelmatsch entsteht, der die Spiele nur schwer spielbar macht und dadurch Kinder und Eltern nichts damit anfangen können.
\newline \newline \tab
- Zweitens: Die komplette Kommunikation zwischen Server und Smartphone findet mit Network Streams statt, welche in einem Thread dauerhaft abgefragt werden. Und auch wird die Rechenleistung eines durchschnittlichen Tablets zum Problem. Da die Kommunikation aber anders nicht reibungslos möglich ist, ist umschreiben des Codes, nur damit es auf Tablets läuft, keine Option. Folglich bleibt nur die Alternative, dass Spiele, welche eine komplizierte Kommunikation benötigen, das heißt wo mehrere Key-Value Pairs pro Sekunde verschickt werden, nicht auf dem Tablet zur Verfügung zu stellen.
\newline \newline
Auch wenn das Team nicht zufrieden war mit der finalen Lösung, manche Spiele einfach nicht für das Tablet zur Verfügung zu stellen, blieb uns keine andere Wahl, da es technisch nicht umsetzbar war. Leider sind genau diese Spiele, welche für das Tablet nun nicht verfügbar sind, genau jene Spiele, mit denen die Kinder am meisten Spaß haben. Somit war das eine der schwersten Entscheidungen im gesamten Projektverlauf, da es eine der Grundideen war, dass alles am Tablet laufen sollte, damit man beim Reisen weniger Gepäck braucht. Zusätzlich war diese Entscheidung mit den vorherigen Spieldesignentscheidungen eine der gravierendsten Änderung im Projekt Ludimus.

\section{Spiele}
\subsection{Poker}
\subsubsection{Erklärung}
Texas Holdem ist eine Poker Variante, wo der Spieler 2 Handkarten bekommt und danach 5 weitere Karten in die Mitte des Pokertisches gelegt werden. Diese 5 Karten kann jeder Spieler zur Bildung seiner Pokerhand verwenden, allerdings dürfen nie mehr als 5 Karten verwendet werden – zB 1 Handkarte und 4 Tischkarten oder 2 Handkarten und 3 Tischkarten. \newline
\textbf{1 Runde} \newline
Jeder Spieler erhält 2 Handkarten, der Dealer (Kartengeber) legt eine Karte verdeckt neben den Kartestapel und deckt drei Karten auf, welche er in die Mitte des Tisches legt. Danach hat der Spieler 3 Möglichkeiten: 
\newline \newline \tab  - Call (halten, mitgehen)
\newline \newline \tab	- Raise (erhöhen)
\newline \newline \tab	- Fold (aussteigen)
\newline \newline
\textbf{2 Runde} \newline
Der Dealer legt wieder eine Karte verdeckt neben den Kartenstapel und eine aufgedeckt in die Mitte des Tisches. Die Spieler haben wieder 3 Möglichkeiten (wie oben beschrieben). \newline
\textbf{3 Runde} \newline
Diese läuft analog zu der zweiten Runde ab. \newline
\textbf{Showdown} \newline
Es stellt jeder Spieler aus den 5 aufgedeckten Karten am Tisch und seinen 2 Handkarten die bestmögliche Kombination zusammen – wobei die 6te und 7te Karte für die Gewinnermittlung bedeutungslos ist.
Jener Spieler mit der höchsten Hand (Kombination) gewinnt den Pot. Falls 2 Spieler oder mehr den gleichen Kartenwert haben, spricht man von einem Split Pot – der Gewinn wird geteilt.
\subsubsection{Geschichte}
Poker wurde als Proof of Concept benutzt, da es für unser System perfekt ist. Anhand von Poker erklärten wir Außenstehenden, wie unsere Plattform funktioniert. Es war das zweite Spiel der Ludimus-Plattform, wurde aber nicht auf die neue Plattform angepasst, da sich Ludimus von Kartenspielen distanziert hatte und Familienspiele entwickeln wollte. Poker wird nun auch nicht mehr zur Erklärung benutzt, da wir zu oft gefragt wurden, warum wir eine Familienspielplattform mit Poker erklären wollen und nicht mit einem Familienspiel.
\subsubsection{Aufbau}
Es gibt eine PokerPlayer Klasse in welcher alles wichtige für den Spieler geregelt wird. In dieser stehen sein Player-Objekt, zur Verbindung mit dem Smartphone, sein Geld und die Karten die er zurzeit hat. Zusätzlich gibt es auch eine Tisch Klasse, welche die Karten des Tisches und den gesamten Pot speichert. Die Kommunikation ist dabei so aufgebaut, dass am Anfang ein Key-Value Pair zum Smartphone geschickt wird, welches zwei random generierte Karten enthält und so aussehen kann: “Cards|P7:K4;”. Mit dem Keyword Cards wird dem Smartphone kommuniziert, dass es jetzt seine Karten bekommt. Mit P7 ist Pik 7 gemeint bzw mit K4 Karo 4. Nun weiß das Smartphone welche Karten es darstellen muss. Wenn der Spieler an der Reihe ist bekommt er: “Turn|1;” geschickt, wobei Turn das Keyword für seinen Zug ist und 1 signalisiert True. Nun werden am Smartphone alle mögliche Züge angezeigt. Die Antwort an den Server ist dabei so aufgebaut, dass als Keyword sein Zug und als Value das Geld welches er setzt, default 0, gesendet wird. Zum Beispiel: “Check|0;”,”Fold|0;” oder auch “Bet|1000;”. Nach fünf durchgängen checkt ein Algorithmus welcher Spieler gewonnen hat und gibt diesem das Geld und zeigt dessen Namen an.
\subsubsection{Schwierigkeiten}
Um zu ermitteln wer gewonnen hat, gibt es leider keine simple Formel oder einen einfachen Algorithmus. Um beim Pokerspielen zu ermitteln wer gewonnen hat, muss man alle Karten mit den am Tisch liegenden vergleichen. Es führt hier kein Weg an einer lange IF-Verkettung vorbei, die alle Möglichkeiten überprüft und dann schaut wie viel sein Blatt wirklich Wert ist. Den Spielablauf zu programmieren hingegen erwies sich als simple.
\subsection{Jumpy} \label{jumpy}
\subsubsection{Erklärung}
Bei Jumpy können maximal vier Spieler gegeneinander ein Rennen zu der Zielflagge antreten. Dabei bewegt der Spieler den Charakter, welcher durch Augen visualisiert wird, mit drei Buttons auf dem Smartphone. Ein Button mit einem Pfeilsymbol nach links für die Bewegungen nach links, analog dazu einen Button für die Bewegung nach rechts. Ganz rechts befindet sich der Button für das Springen, der mit einem Pfeil nach oben gekennzeichnet ist. Zusätzlich kann ein Charakter sich mit Hilfe der Sprungtaste von einer Wand abstoßen, um noch höher zu kommen. Dabei ist es gewollt, dass der Spieler eine Wand hoch kann, indem er sich immer abstößt und wieder zur Wand springt. Dies gibt den Spielern noch mehr Freiheiten, das Level zu gestalten. Nach jeder Runde gibt es für die Spieler, welche das Ziel erreichen, Punkte. Der Spieler der als Erster das Ziel erreicht erhält zusätzliche Punkte. Bevor die nächste Runde beginnt, darf der Sieger der vorhergehenden Runde ein Objekt im Level platzieren und somit das Level umgestalten. Auf diese Art können die Spieler ein zu leichtes Level schwerer machen beziehungsweise ein zu schweres Level einfacher gestalten.
Zur Verfügung stehen den Spielern dazu Plattformen, welche wie normale Levelwände agieren, Sprungbretter, welche die Spieler höher springen lassen, ein Ventilator, welcher die Spieler in die Luft befördert und Stacheln, welche bei Berührung einen Spieler sofort aus der Runde ausscheiden lassen. Für die Bewegung des Objektes wird das UI am Smartphone ausgetauscht und der Spieler sieht nun vier Richtungspfeile. Die Pfeile agieren als Buttons und senden den Befehl an das Spiel, der das Objekt in die gewünschte Richtung bewegt. Zusätzlich erscheint ein Häkchen-Button am UI durch dessen Betätigung der Befehl zur Festigung des Objektes an das Spiel gesendet wird.
\subsubsection{Geschichte}
Jumpy entstand als Demospiel für das AEC-Festival, wurde am Ende aber weit mehr. Das Spiel kam am AEC-Festival so gut an, dass wir es überarbeitet und optisch verbessert haben. 
Mehr dazu bei der Idee für das AEC-Festival \ref{aecerror}
\subsubsection{Aufbau}
Der Kommunikationsaufbau bei Jumpy ist sehr einfach gehalten. Wenn ein Spieler auf einen Button drückt wird der jeweilige Befehl an den Server in Form eines Key-Value Pairs gesendet, welches keinen Value hat. Bsp.: “startLeft|;”, “stopLeft|;”, “jump|;”. Wenn der Spieler das Ziel erreicht wird dem Controller geschickt, dass er sich nicht mehr bewegen kann. Zum Handling im Backend gibt es drei Listen: ActivePlayers, WinPlayers, DeadPlayers. Wenn ein Spieler das Ziel erreicht, wird er von ActivePlayers zu WinPlayers kopiert. Wenn er jedoch ausscheidet wird er zu DeadPlayers kopiert. Wenn die Anzahl von WinPlayers + DeadPlayers der von ActivePlayers gleicht ist eine Runde zu Ende. Nun bekommt jeder in WinPlayers seine Punkte, welche auf seinem JumpyPlayer-Objekt festgeschrieben werden. Der Erste der Liste WinPlayers darf nun ein Objekt bewegen, welches aus den Unity-Assets geladen wird. Welches Objekt er bewegen darf, wird mit einem von C\# bereitgestellten Random berechnet. Dieser Random funktioniert, indem man zunächst ein Random-Objekt instanziiert: Random random = new Random();. Mit der Methode .Next(int Untergrenze, int Obergrenze) kann man nun einen Randomwert in dem Wertebereich erzeugen, dabei ist wichtig, dass die Untergrenze inklusiv und die Obergrenze exklusiv sind. Das heißt random.Next(0,100) bedeutet, man bekommt einen Wert, welcher von 0-99 reicht. Will man einen Wert von 0-100 haben, muss der Randomwert wie folgt erzeugt werden: random.Next(0,101. Der Randomwert, welcher von der .Next Methode erzeugt wird ist keine echte Zufallszahl, da diese mit einem Computer weit schwerer zu erzeugen ist, reicht jedoch für die Benutzung in Jumpy aus. Danach spielt man Runde für Runde bis zu dem Zeitpunkt wo der Score eines Spielers den fix eingestellten Wert überschreitet.
\subsubsection{Schwierigkeiten}
Die erste große Hürde war der Walljump, also die Mechanik, dass ein Spieler sich von der Wand abstoßen kann, um ihr hochzuklettern. Dazu wurde ein System eingebaut, welches bei einer Objekt-Berührung berechnet, von welcher Seite das Objekt die Wand berührt. Auch bei der Bewegung des Charakters gab es zunächst Probleme, da der Charakter sich solange bewegen sollte, wie der Spieler nach links/rechts drückt. Bei Unity Buttons jedoch gibt es nur ein Event, wenn man den Button drückt und loslässt. Bei der fertigen Anwendung wird beim Drücken eines Buttons ein Befehl geschickt. welcher den Spieler so lange in die gewünschte Richtung bewegt, bis der Spieler den Button loslässt und ein Stopp-Befehl geschickt wird. Dazu wurden eigene Events geschrieben. Beim Platzieren des Objektes gab es die Schwierigkeit zwischen Objekt und Spielcharakter umzuschalten. Die Lösung wurde implementiert, indem der Spielercharakter, nach erreichen des Zieles oder beim Ausscheiden während einer Runde, einfriert. Währenddessen wird ein neues Objekt aus den Assets instanziiert und mit einer Variable übergeben. Nun kann der Spieler mit dem neuen UI, welches per Befehl vom Server geändert wurde, das Objekt platzieren. Wenn die Bestätigung für die Position des Objektes vom Server erhalten wird, wird das Objekt in eine Liste hinzugefügt, welche alle durch Spieler platzierten Objekte enthält. Zum Schluß wird die Variable auf null gesetzt und dem Smartphone gesendet, dass es das UI wieder wechseln muss. Anfänglich fiel es uns schwer für das Spiel ein Design zu finden, das unseren Ansprüchen gerecht wurde. Wir sind aber schließlich mit dem Endergebnis sehr zufrieden und stolz.
\subsection{Knightslider}
\subsubsection{Erklärung}
Bei Knightslider werden die Spieler als Ritter dargestellt. Es gibt 3 Lanes auf welchen man stehen kann und mit einem wischen auf dem Smartphone kann man die Lane wechseln um Objekten, welche herunterfallen, auszuweichen. Sobald man von einem der fallenden Objekte getroffen wird, scheidet man aus. Das Ziel ist als letzter noch im Spiel zu sein.
\subsubsection{Geschichte}
Wir wollten für Ludimus ein zweites Endless Runner Arcade-Spiel, da diese schnell erklärt sind und viel Spaß machen, auch wenn man sie nicht so gut kann. Die Idee als Spielfigur einen Ritter zu nehmen entstand eher spontan.
\subsubsection{Aufbau}
Bei Knightslider wird vom Smartphone gesendet, in welche Richtung sich der Spieler bewegen will. Dies geschieht mit den üblichen Key-Value Pairs, welche hier den Aufbau :Move|-1;” oder Move|1;” haben. Wobei -1 hier links und 1 rechts bedeutet.
\subsubsection{Schwierigkeiten}
Bei der Programmierung selbst traten keine größeren Probleme auf, bei der Modellierung des Designs jedoch schon. Bei Knightslider haben wir das erste mal richtige 3D-Modelle verwendet und das Team hatte bisher keine Erfahrung wie man 3D modelliert. Zum Glück gibt es Blender (\ref{sec:blender}). Durch dieses Programm hatten wir die Möglichkeit unsere 3D Objekte selbst und schnell zu modellieren.
\subsection{Billard}
\subsubsection{Erklärung}
Beim Billard liegen 16 Bälle auf einem Billardtisch, welcher eine spezielle Oberfläche hat. Dabei gibt es eine weiße, 7 halb gefärbte, 7 komplett gefärbte und eine schwarze Kugel. Ziel des Spieles ist es, mit einem Stab, welcher Queue genannt wird, die weiße Kugel so anzustoßen, dass sie eine weiter Kugel trifft und diese in eine Ecke des Tisches befördert. In den 4 Ecken des Tisches und auf den beiden Längen, jeweils in der Hälfte, sind Löcher. Eine Kugel gilt dann als versenkt, wenn die Kugel in einem der Löcher landet. Gewonnen hat der Spieler, welcher zuerst alle Kugeln seiner Farbe versenkt und dann noch die schwarze Kugel in das richtige Loch trifft. Wer ganze und wer halbe Kugeln hat wird durch die erste versenkte Kugel entschieden. Wer die schwarze Kugel zu früh in eines der Löcher befördert, verliert automatisch das Spiel.
\subsubsection{Geschichte}
Zunächst wollten wir ein anderes Spiel implementieren, bei welchem man eine Kugel steuert und andere Kugeln wegstoßen muss. Bei der Entwicklung jedoch erhielten wir immer wieder das Feedback, dass wir Billard programmieren sollten. Irgendwann gab das Team nach und programmierte das Spiel zu richtigem Billard um.
\subsubsection{Aufbau}
Der erste Kommunikationsaustausch findet statt, wenn der Spieler sein Smartphone berührt. Dabei wird der Koordinatenvektor mitgeschickt, welcher vom Spiel vermerkt wird. Wenn der Spieler nun seinen Finger vom Smartphone hebt wird der Endvektor an den Server gesendet. Dieser berechnet sich durch die beiden Vektoren: in welche Richtung der Spieler gezielt hat und durch die Distanz der beiden Vektoren wie fest der Spieler stoßen will. Wenn der Server das berechnet hat, bewegt er die weiße Kugel um diesen berechneten Vektor. Durch die Physik des Spieles werden alle Kugeln, welche berührt werden, automatisch weggeschoben.
\subsubsection{Schwierigkeiten}
Die Physik des Spieles. Der Kommunikationsaustausch war ohne Probleme programmiert. Die Kugeln allerding richtig anzeigen und berechnen war hier die wahre Herausforderung. Mit Unity Materials gelang es uns schlussendlich doch eine gut funktionierende Physik einzubauen.
\subsection{Squarerunner}
\subsubsection{Erklärung}
Ein Arcade-Game bei dem es hauptsächlich um Geschicklichkeit geht. Der Spieler steuert ein würfelförmiges Objekt und muss Hindernissen ausweichen. Zum Steuern des Würfels kann der Spieler sein Handy nach Links und Rechts neigen. Ziel ist es, den entgegenkommenden Blöcken auszuweichen und als letzter Spieler noch am Leben zu sein.
\subsubsection{Geschichte}
Squarerunner war zunächst ein auf Unity basierendes Geschicklichkeitsspiel für das Smartphone, entwickelt von meinem Kollegen David Matousch. Der Code für dieses Spiel wurde umfunktioniert und auf eine Server-Client Verbindung aufgeteilt. Zusätzlich wurde noch die Ludimus-Schnittstelle mit Hilfe der bereitgestellten Delegates implementiert. Squarerunner war das erste Spiel von Ludimus.
\subsubsection{Aufbau}
Das Spiel funktioniert indem die einzelnen TCP-Client-Verbindungen alle 0.25 Sekunden die Neigung ihres Smartphones übermitteln. Beispiel des Aufbaus der gesendeten Key-Value Pairs:
“Tilt|0.51;” oder “Tilt|-0.5;”. Mit Hilfe der Neigung kann man berechnen, wie der Spieler sein Smartphone hält und in welche Richtung er seinen Charakter bewegen will.
\subsubsection{Schwierigkeiten}
Die Neigung unter Unity zu berechnen war das größte Problem bei Squarerunner. Zum Glück war auch dies lösbar, denn mit:
\newline 
- Input.acceleration.x
\newline
- Input.acceleration.z
\newline
- Input.acceleration.y
\newline
kann man in Unity schnell und einfach die Rotation des Smartphones feststellen.
Zusätzlich traten bei diesem Spiel auch sehr viele Fehler in Zusammenhang mit der Nutzung der Network Streams auf, da es das erstes Spiel war und wir uns erst vertraut mit der Materie machen mussten.
