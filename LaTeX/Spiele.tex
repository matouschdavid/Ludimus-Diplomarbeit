\section{Spieleentwicklung für Ludimus}
\subsection{Grundgedanke}
Grundgedanke:
Ein Grundgedanke bei der Entstehung von Ludimus war schon immer das andere Entwickler für Ludimus Spiele entwickeln. Da Ludimus eine Spieleplattform ist benötigt sie ja auch viele Spiele und diese alleine zu entwickeln ist nahezu ein Ding der Unmöglichkeit, deshalb sollten Entwickler, welche C Sharp beherrschen mit hilfe unserer Dokumentation eigenständig Spiele entwickeln können, welche wir nach einem Qualitätscheck dann in unsere Plattform aufnehmen.
Dazu haben wir auch Ludimus so “offen” wie nur möglich programmiert. Es sollen den Entwicklern so viele Schnittstellen wie nur möglich gegeben sein, damit diese so kreativ wie möglich werden können. Zusätzlich wird jedoch auch auf Qualität geachtet da nicht jedes Spiel auf unserer Plattform erwünscht ist, da die Ludimus Hauptzielgruppe Familien beinhaltet und somit auch in die Entwicklung seines eigenen Spiels darauf geachtet werden muss Kinderfreundlich zu bleiben. 
\subsection{Motivation}
Warum sollte man nun ein Spiel für diese fremde Plattform entwickeln? Als Motivation für Entwickler dient zum einem das Gefühl, dass eventuell hunderte bis tausende Familien ihr Spiel spielen und damit Spaß haben. Andererseits aber auch Geld. Jeder Programmierer der sein Werk auf unserer Plattform veröffentlicht kann damit Geld verdienen, jedoch gibt es keine feste Bezahlung. Den Entwicklern stehen 30% des gesamten Gewinns zur verfügung. Je nachdem wie oft sein Spiel gespielt wird bekommt ein Entwickler Prozente von diesem Pool. Das heißt ein Entwickler welcher bereits 5 Spiele programmiert hat und diese alle sehr oft gespielt werden bekommt zum Beispiel von diesem 30% Pool wiederum 14%. Ein Programmierer der jedoch nur ein Spiel entwickelt hat und dieses wird nicht so oft gespielt erhält von den 30% nur 1,2%. Somit können Entwickler welche viel und gute Spiele programmieren mit Ludimus Geld verdienen und haben mehr ansporn immer neue Spiele zu liefern. 
\subsection{Wie programmiere ich Spiele für Ludimus}
Wenn man sich dazu entschließt Spiele für Ludimus zu entwickeln benötigt man bereits Kenntnisse in C Sharp und Unity, da Ludimus auf C Sharp und Unity aufbaut. Um ein Spiel zu erstellen benötigt man zwei Unityprojekte. Eins für das was am Server angezeigt wird und ein zweites für das was die Spieler am Handy sehen. Nun gibt es 3 wichtige Klassen welche der Programmierer wissen muss um die Ludimusschnittstellen auch nutzen zu können. Dies sind der Playermanager und der Player für den Server und der ClientController für das Smartphone.
Die einzelnen Klassen werden bereits im Abschnitt “Für Verbindung wichtige Klassen und Methoden / Schnittstellen” behandelt. Es werden alle Methoden aufgezeigt welche ein Entwickler zur verfügung hat und auch alle Delegates auf welche sich der Programmierer subscriben kann und somit eigene Methoden dem Player zuweisen kann. Am wichtigsten hierbei sind der InputHandler der Player Klasse und der InputHandler des ClientControllers. Diese werden aufgerufen wenn der jeweils andere, per Network Stream, ein Key-Value Pair schickt und es noch keine vordefinierte Funktion dafür gibt. Die vordefinierten Keys sind unter der jeweiligen “Übersicht der Verbindung“ zu finden.
\subsection{Testen}
Zum Testen der Spiele für Ludimus gibt es einen eigenen Debugmodus. Mehr unter \ref{sec:debug-modus}
\section{Vorgang Spieleauswahl}
Bei der Spieleauswahl für Ludimus ging es zunächst um Spiele die jeder kennt, wie zum Beispiel Poker, welches auch für den Proof of Concept benutzt wurde. Ludimus war am Anfang eine Plattform für Brett,- Karten- und Arcadespiele. Sie ist es noch immer jedoch distanzierten wir uns von der Idee Kartenspiele auf Ludimus langsam immer weiter da der Sinn von Ludimus ist viele Spiele auf einmal mitnehmen zu können und dies bei Kartenspielen nicht sinnvoll erscheint. Kartenspiele sind meist extremst klein und man kann mit einem einfachen Pokerkartenset schon sehr viele verschiedene Spiele spielen. Dazu benötigt man keine eigene Plattform. Für Spiele welche jedoch extremst viel Platz im Koffer brauchen und zusätzlich noch teuer sind jedoch macht es Sinn sie zu digitalisieren und alle auf einer Plattform zu haben. Auch macht es Sinn Spiele welche nur digital spielbar sind oder eine eigene Idee auf der Plattform vertreten zu haben. Also soll Ludimus mehr eine Brett- und Arcadespiele Sammlung sein? Nein.
Im Laufe der Zeit änderte sich der Fokus von der Zielgruppe “jeder” auf die Zielgruppe Familie. Dies hatte zur Folge das wir nicht mehr Spiele benötigten welche jeder kennt sonder welche die Kindern und Eltern spaß machen. Auch wurde uns klar das Kinder eher Arcadespiele, welche schnell und einfach zu verstehen sind, spielen, als Brettspiele welche lang dauern und eine lange Erklärung benötigen. Zusätzlich weichen unsere Milestones von den tatsächlichen Spielen weit ab, in der Anzahl und in der Art. Warum die Art sich verändert ist bereits erklärt. Warum sich jedoch die Anzahl veränderte hat auch einen einfachen Grund: Qualität. Eine Plattform welche sich an Eltern und Kinder richtet muss Qualitativ hochwertig sein und auch die Spiele müssen poliert sein. Die Plattform selbst wurde zwei mal neu geschrieben da wir mit der Qualität der vorherigen nicht zufrieden waren, zu wenig Schnittstellen hatten oder eine andere Technologie verwendet wurde. Auch bei den Spielen wurde auf Qualität und nicht Quantität gesetzt, so wurden aus den zehn angestrebten Spiele vier Spiele welche sich jedoch gut spielen und keine Fehler aufweisen.
\section{Probleme bei der Spiele Entwicklungen}
Bei der Spieleentwicklung stießen wir auf viele Probleme, welche meistens aber nur das jeweilige Spiel beeinflussen und deshalb erst später aufgelistet werden. Es gab jedoch auch Probleme welche alle Spiele betreffen, zum Beispiel eine Lösung wie die Spiele zur Runtime geladen werden oder wie die Spiele Zugriff auf die Player-Objekte erhalten. All diese Probleme hatten eine relativ einfache Lösung, nur eines nicht. Ludimus auf dem Tablet! Wie genau soll das Tablet die Rechenleistung eines Laptops/PCs schaffen? Es gibt dabei vor allem 2 große Unterprobleme.
\newline \newline \tab 
- Erstens, Spiele welche schön ausschauen brauchen nunmal viel Rechenleistung. Rechenleistung die ein Tablet nicht zur verfügung hat. Hierfür gibt es 2 Lösungsansätze und keiner davon ist perfekt. Aber zunächst; warum soll das Spiel schön ausschauen? Grundsätzlich müssen Spiele nicht schön sein aber Kinder und Eltern werden lieber etwas spielen was auf sie optisch einen guten Eindruck macht, da es von Qualität zeugt wenn kein Pixelmatsch auf dem Bildschirm ist. Auch macht es einfach mehr Spaß wenn die Kinder erkennen was genau sie jetzt im Spiel machen und nicht raten müssen was diese Pixel überhaupt darstellen sollen. Lösungsansätze:
\newline \newline \tab \tab 
- Man kann bestimmte Spiele einfach nur auf dem PC/Laptop anbieten. Diese Spiele sind dann unmöglich am Tablet zu spielen, Problem gelöst. Nicht ganz dem zahlenden User wird die Anzahl der Spiele eingeschränkt nur weil er nicht seinen PC in den Urlaub schleppen will. Zusätzlich ist hier ein großer Faktor das der User dann zwar die Möglichkeit hat einfache Spiele zu spielen, diese aber meistens den Kindern nicht so gut gefallen wie die grafisch anspruchsvollen Spiele, zum Beispiel gefällt den meisten Kindern ein grafisch heraus geputztes Geschicklichkeitsspiel mehr als eine Runde Poker.
\newline \newline \tab \tab 
- Man kann die Spiele grafisch für das Tablet downgraden. Dies erfordert viel Arbeit welche wir nicht zur Verfügung haben und man rutscht schnell ab und hat dann wieder einen Pixelmatsch mit denen Kinder und Eltern nichts anfangen können.
\newline \newline 
Für eine der beiden Lösungen sich zu entscheiden fiel dem Team schwer da beide fast nur Nachteile bieten. Jedoch entschloß sich das Team mit der ersten Lösung, da die Nachteile beim grafischen Downgraden zu groß waren. Auch spielte hier das zweite Problem eine große Rolle.
\newline \newline \tab
- Zweitens, die komplette Kommunikation zwischen Server und Smartphone findet mit Network Stream statt, welche in einem Thread dauerhaft abgefragt werden. Und wieder finden wir hier das Problem mit der Rechenleistung eines durchschnitts Tablets wieder. Da die Kommunikation aber nicht anders ordentlich möglich ist, ist umschreiben des Codes, nur damit es auf Tablets läuft nicht möglich. Hier bleibt eigentlich nur die Option Spiele welche eine komplizierte Kommunikation benötigen, das heißt mehrere Key-Value Pairs pro Sekunde verschickt werden, nicht auf dem Tablet zur Verfügung zu stellen. 
\newline \newline
Auch wenn das Team nicht zufrieden war mit der Endlösung, manche Spiele einfach nicht für das Tablet zur Verfügung zu stellen, blieb uns keine andere Wahl da die Technik es nicht erlaubt. Leider waren genau diese Spiele, welche für das Tablet nun nicht verfügbar sind, genau die Spiele mit denen die Kinder am meisten Spaß haben. Somit war das eine der schwersten Entscheidungen im kompletten Projekt, da es auch eine der Grundideen war, das alles am Tablet laufen sollte damit man beim Reisen noch weniger Platz braucht. Zusätzlich war diese Entscheidung mit den vorherigen Spieldesignentscheidungen eine der gravierendsten Änderung im Projekt Ludimus.

\section{Spiele}
\subsection{Poker}
\subsubsection{Erklärung}
Gespielt wird mit einem klassischen Poker-Kartenset welches aus 52 Karten besteht und in welchem es zwei verschiedene Farben, Schwarz und Rot gibt. Zusätzlich hat jede Karte noch eine Art, wobei es hier vier verschiedene gibt: Herz, Karo, Pik und Kreuz. Jede dieser Arten hat die Karten 2-10 und noch Junge, Dame, König und Ass. Beim Texas Holdem Pokerspiel erhalten alle Mitspieler zwei Karten. Danach kommen 5 Karten verdeckt auf den Tisch, nun werden im Uhrzeigersinn Aktionen ausgeführt. Der Spieler hat drei Aktionen zur Verfügung: 
\newline \newline \tab 
- Check: Der Spieler gibt an den nächsten Spieler weiter ohne zu erhöhen. Check \tab kann nur durchgeführt werden wenn in dieser Runde noch nicht erhöht wurde.
\newline \tab 
- Setzen: Der Spieler setzt teil seines Geldes und erhöht somit den gesamt Pot. \tab Ein Spieler kann maximal sein gesamtes Geld setzen, auch genannt All-In.
\newline \tab 
- Ablegen: Der Spieler wirft sein Blatt weg und steigt aus. Er kann das aktuelle \tab Blatt nicht mehr gewinnen und hat sein bis jetzt gesetztes Geld verloren.
\newline \tab 
- Mitgehen: Der Spieler kann mitgehen wenn in der aktuellen Runde jemand \tab bereits etwas gesetzt hat. Er setzt automatisch den Betrag zwischen dem bereits \tab von ihm Gesetzten und dem maximal Gesetzten.
\newline \newline
Das ganze wird pro Blatt fünfmal wiederholt. Nach der ersten Runde werden jedoch die ersten drei Karten am Tisch umgedreht nun erhält der Spieler einen besseren Eindruck, von dem was er vielleicht für einen Kartenwert hat. Nach der nächsten Runde wird die nächste Karte aufgedeckt und nach der nochmal nächsten Runde wird die letzte Karte aufgedeckt. Wenn alle Karten aufgedeckt sind startet die letzte Runde. Nach dieser werden die Karten, von allen Spielern welche noch im Spiel sind, aufgedeckt und es gewinnt der Spieler mit dem höchsten Blattwert.
\subsubsection{Geschichte}
Poker wurde als Proof of Concept benutzt da es für unser System perfekt ist. Poker wurde auch immer benutzt um Leuten zu erklären wie unsere Plattform funktioniert, da es mit Poker leicht zu erklären ist. Es war das zweite Spiel der Ludimus-Plattform, wurde aber nicht auf die neue Plattform angepasst, da sich Ludimus von Kartenspielen distanzieren wollte und Familienspiele entwickeln wollte. Poker wird auch nicht mehr zur Erklärung benutzt, da wir zu oft gefragt wurden warum wir eine Familienspielplattform mit Poker erklären wollen und nicht mit einem Familienspiel.
\subsubsection{Aufbau}
Es gibt eine PokerPlayer Klasse in welcher alles wichtige für den Spieler geregelt wird. In dieser stehen sein Player-Objekt, zur Verbindung mit dem Smartphone, sein Geld und die Karten die er zurzeit hat. Zusätzlich gibt es auch eine Tisch Klasse welche die Karten des Tisches und den gesamten Pot speichert. Die Kommunikation ist dabei so aufgebaut das am Anfang ein Key-Value Pair zum Smartphone geschickt wird, welches zwei random generierte Karten enthält und so aussehen kann: “Cards|P7:K4;”. Mit dem Keyword Cards wird dem Smartphone gesagt er bekommt jetzt seine Karten und mit P7 ist Pik 7 gemeint bzw mit K4 Karo 4. Nun weiß das Smartphone welche Karten es darstellen muss. Wenn der Spieler an der Reihe ist bekommt er: “Turn|1;” geschickt, wobei Turn das Keyword für seinen Zug ist und ein signalisiert True. Nun werden am Smartphone alle mögliche Züge angezeigt. Die Antwort an den Server ist dabei so aufgebaut das als Keyword sein Zug und als Value das Geld welches er setzt, default 0, gesendet wird. Zum Beispiel: “Check|0;”,”Fold|0;” oder auch “Bet|1000;”. Nach fünf durchgängen checkt ein Algorithmus welcher Spieler gewonnen hat und gibt diesem das Geld und zeigt dessen Namen an.
\subsubsection{Schwierigkeiten}
Um zu ermitteln wer gewonnen hat gibt es leider keine simple Formel oder einen Algorithmus. Um beim Poker spielen zu ermitteln wer nun gewonnen hat muss man leider alle Karten mit den am Tisch liegenden vergleichen. Es führt leider hier kein weg um eine lange IF-Verkettung welche alle Möglichkeiten überprüft und dann schaut wie viel sein Blatt wirklich wert ist. Den Spielablauf zu programmieren hingegen erwies sich als simple.
\subsection{Jumpy}
\subsubsection{Erklärung}
Bei Jumpy müssen maximal vier Spieler gegeneinander ein Rennen zu der Zielflagge antreten. Dabei bewegt der Spieler den Charakter, welcher durch Augen visualisiert wird, mit drei Button auf dem Smartphone. Einer Links, welcher auch nach links zeigt, für die Bewegung nach Links, einer ganz rechts, welcher nach oben zeigt, für das Springen und einer Mittig, welcher nach rechts zeigt, für die Bewegung nach rechts. Auch kann ein Charakter sich von einer Wand abstoßen, mit hilfe der Sprungtaste, um noch höher zu kommen. Dabei ist es gewollt das der Spieler eine Wand hoch kann indem er sich immer abstößt und wieder zur Wand springt. Dies gibt den Spielern noch mehr Freiheiten das Level zu gestalten. Nach jeder Runde gibt es für die Spieler welche das Ziel erreichen Punkte, der Spieler der zuerst das Ziel erreicht erhält mehr Punkte. Bevor aber die nächste Runde anfängt darf der Spieler, der zuerst das Ziel erreicht hat ein Objekt in dem Level platzieren und somit das Level umgestalten. Auf diese Art kann der Spieler ein zu leichtes Level schwerer machen und ein zu schwerer Level einfacher gestalten.
Zur Verfügung stehen dem Spieler dazu Plattformen, welche wie normale Levelwände agieren, Sprungbretter, welche den Spieler höher springen lassen, einen Ventilator, welcher den Spieler in die Luft befördert und Stacheln, welche bei der Berührung den Spieler sofort aus der Runde ausscheiden lässt. Für die Bewegung des Objektes wird das UI am Smartphone ausgetauscht und der Spieler sieht nun vier Pfeile in alle Richtungen, Unten, Oben, Links und Rechts. Die Pfeile agieren als Buttons und senden den Befehl an das Spiel, der das Objekt in die gewünschte Richtung bewegt. Auch wird ein Häkchenen-Button am UI erscheinen durch welche Betätigung der Befehl zur Festigung des Objektes an das Spiel gesendet wird.
\subsubsection{Geschichte}
Jumpy entstand als Demospiel für das AEC-Festival wurde aber weit mehr. Das Spiel kam am AEC-Festival so gut an, dass wir es nochmal überarbeitet und optisch verbesserten. 
Mehr dazu bei der Idee für das AEC-Festival \ref{aecerror}
\subsubsection{Aufbau}
Der Kommunikationsaufbau bei Jumpy ist sehr einfach gehalten. Wenn ein Spieler auf einen Button drückt wird der jeweilige Befehl an den Server in Form eines Key-Value Pairs gesendet welches keinen richtigen Value hat. Bsp.: “startLeft|;”, “stopLeft|;”, “jump|;”. Wenn der Spieler nun das Ziel erreicht wird ihm geschickt, dass er sich nicht mehr bewegen kann. Zum Handling im Backend gibt es drei Listen: ActivePlayers, WinPlayers, DeadPlayers. Wenn ein Spieler das Ziel erreicht wird er von ActivePlayer zu WinPlayers transferiert. Wenn er jedoch ausscheidet wird er zu DeadPlayers transferiert. Wenn die Anzahl von WinPlayers + DeadPlayers der von ActivePlayers gleicht ist eine Runde aus. Nun bekommt jeder in WinPlayers seine Punkte welche auf sein JumpyPlayer-Objekt festgelegt werden. Der erste der Liste WinPlayers darf nun ein Objekt bewegen, welches aus den Unity-Assets geladen wird, welches Objekt er bewegen darf wird mit einem, von C\# bereitgestellten Random. Dieser Random funktioniert indem man zunächst ein Random-Objekt instanziiert: Random random = new Random();. Mit der Methode .Next(int Unteregränze, int Obergrenze) kann man nun einen Randomwert in dem Wertebereich erzeugen, dabei ist wichtig das die Untergrenze inklusive und die Obergrenze exklusiv sind, das heißt random.Next(0,100) bedeuted man bekommt einen Wert welcher von 0-99 reicht. Will man einen Wert von 0-100 haben muss der Randomwert so random.Next(0,101) erzeugt werden. Der welcher von der .Next Methode kommt ist jedoch keine echte Zufallszahl da diese mit einem Computer weit schwerer zu erzeugen ist, reicht jedoch für die Benutzung in Jumpy aus. Danach spielt man erneut bis es keine aktiven Spieler hat, bis zu dem Zeitpunkt wo der Score eines Spielers einen gewissen vorher eingestellten Wert erreicht.
\subsubsection{Schwierigkeiten}
Die erste große Hürde war der Walljump, also die Mechanik das ein Spieler sich von der Wand abstoßen kann um an der Wand hoch zu klettern. Dazu wurde ein System eingebaut welches bei einer Objekt-Berührung berechnet von welcher Seite das Objekt die Wand berührt. Auch bei der Bewegung des Charakters gab es Probleme, da der Charakter sich solange bewegen sollte wie der Spieler nach links/rechts drückte. Bei Unity Buttons jedoch gibt es nur eine Event wenn man den Button drückt und auslässt. Bei der fertigen Anwendung wird bei einem Drücken ein Befehl geschickt welcher den Spieler in die gewünschte Richtung solange bewegt, bis der Spieler den Button loslässt und ein Stop-Befehl geschickt wird. Beim Platzieren des Objektes gab es auch die Schwierigkeit wie zwischen Objekt und Spielcharakter umgeschalten wird. Dies wurde so Implementiert indem der Spielercharakter während der Bewegung einfriert und sich nicht bewegen kann. Währenddes wird ein neues Objekt aus den Assets instanziert und mit einer Variable übergeben. Nun kann der Spieler mit dem neuen UI das Objekt platzieren. Wenn die Bestätigung für die Position vom Server erhalten wird, wird das Objekt in eine Liste hinzugefügt, welche alle selbst platzierten Objekte enthält. Zum Schluß wird die Variable auf null gesetzt und dem Smartphone gesendet, dass es das UI wieder wechseln muss. Auch war das Design hier ausgesprochen schwer zu gestalten, da weder mein Kollege und Ich ausgezeichnete Künstler sind. Am Schluss wurden wir aber nach stundenlangem Zeichnen Fertig und sind mit dem Ergebnis sehr zufrieden.
\subsection{Knightslider}
\subsubsection{Erklärung}
Bei Knightslider werden die Spieler als Ritter dargestellt. Es gibt 3 Lanes auf welchen man stehen kann und mit einem wischen auf dem Smartphone kann man die Lane wechseln um Objekten, welche herunterfallen, auszuweichen. Sobald man von einem der fallenden Objekte getroffen wird scheidet man aus. Das Ziel ist als letzter noch im Spiel zu sein.
\subsubsection{Geschichte}
Wir wollten für Ludimus ein zweites endless runner Arcade-Spiel, da diese schnell zu kapieren sind und viel Spaß machen, auch wenn man sie nicht so gut kann. Die Idee einen Ritter zu nehmen entstand eher spontan.
\subsubsection{Aufbau}
Bei Knightslider wird vom Smartphone gesendet in welche Richtung sich der Spieler bewegen will. Dies geschieht mit den üblichen Key-Value Pairs welche hier den Aufbau :”right|;” oder “left|;” haben.
\subsubsection{Schwierigkeiten}
Bei der Programmierung selbst traten keine größeren Probleme auf, bei der Modellierung jedoch schon. Bei Knightslider haben wir das erste mal richtige 3D-Modelle verwendet und das Team hatte vorher keine Ahnung wie man 3D modelliert. Zum Glück gibt es Blender \ref{Blender}, durch dieses Programm hatten wir die Möglichkeit unsere 3D Objekte selbst und schnell zu modellieren.
\subsection{Billard}
\subsubsection{Erklärung}
Beim Billard liegen 16 Bälle auf einem Billardtisch, welcher eine spezielle Oberfläche hat. Dabei gibt es 1ne Weiße, 7 halb gefärbte, 7 komplett gefärbte und 1ne Schwarze Kugel. Ziel des Spieles ist es mit einem Stab, welcher Queue genannt wird, die weiße Kugel so anzustoßen dass sie eine weiter Kugel anstößt und diese in eine Ecke des Tisches befördert. In den 4 Ecken des Tisches und auf den beiden Längen, jeweils in der Hälfte, sind Löcher. Eine Kugel gilt dann als versengt wenn die Kugel in einem der Löcher landet. Gewonnen hat der Spieler, welcher zuerst alle Kugeln seiner Farbe, dies wird durch die erste Kugel welche versenkt wird entschieden, versenkt und dann noch die schwarze Kugel in das richtige Loch trifft. Die schwarze Kugel jedoch darf erst ganz am Schluss versenkt werden da man sonst automatisch das Spiel verliert.
\subsubsection{Geschichte}
Zunächst wollten wir ein anderes Spiel zu implementieren bei welchem man eine Kugel steuert und andere Kugeln wegstoßen muss. Bei der Entwicklung jedoch erhielten wir immer wieder das Feedback das wir einfach Billard programmieren sollten. Nach einer Ewigkeit gab das Team nach und programmierte das Spiel schnell zu einem richtig Billard um.
\subsubsection{Aufbau}
Der erste Kommunikationsaustausch findet statt wenn der Spieler sein Smartphone berührt. Dabei wird der Koordinatenvektor mit geschickt welcher vom Spiel vermerkt wird. Wenn der Spieler nun seinen Finger vom Smartphone hebt wird der Endvektor an den Server gesendet. Dieser berechnet sich, durch die beiden Vektoren, in welche Richtung der Spieler gezielt hat und durch die Distanz der beiden Vektoren wie fest der Spieler schießen will. Wenn er das berechnet hat, bewegt dann die weiße Kugel um diesen berechneten Vektor. Durch die Physik des Spieles werden alle Kugeln welche berührt werden automatisch weggeschoben.
\subsubsection{Schwierigkeiten}
Die Physik des Spieles. Der Kommunikationsaustausch war schnell erledigt, das die Kugeln jedoch richtig angezeigt und berechnet werden war schon um einiges schwerer. Mit Unity Materials glang es uns jedoch schlussendlich doch eine gut funktionierende Physik einzubauen.
\subsection{Squarerunner}
\subsubsection{Erklärung}
Ein Arcade-Game bei welchem es hauptsächlich um Geschicklichkeit geht. Der Spieler steuert einen Würfel, auf dem PC/Laptop, mit seinem Smartphone. Zum Steuern des Würfels kann der Spieler sein Handy nach Links und Rechts neigen. Ziel ist es den entgegenkommenden Blöcken auszuweichen und als letzter Spieler noch am Leben zu sein.
\subsubsection{Geschichte}
Square runner war zunächst ein, auf Unity basierendes, Geschicklichkeitsspiel für das Smartphone, entwickelt von meinem Kollegen David Matousch. Der Code für dieses Spiel wurde kurz umfunktioniert und auf eine Server- Client Verbindung aufgeteilt. Zusätzlich wurde noch die Ludimus Schnittstelle mit hilfe den bereitgestellten Delegates implementiert und schon war das erste Spiel der Ludimus-Spieleplattform fertig.
\subsubsection{Aufbau}
Das Spiel funktioniert indem die einzelnen TCPClient-Verbindungen jede 0.25 Sekunden die Neigung ihres Smartphones übermitteln. Beispiel des Aufbaus der gesendeten Key-Value Pairs:
“Tilt|0.51;” oder “Tilt|-0.5;”. Mit hilfe der Neigung konnte man berechnen wie der Spieler sein Smartphone hält und in welche Richtung er seinen Charakter bewegen will.
Schwierigkeiten:
Die Neigung unter Unity zu berechnen war das größte Problem bei Square Runner. Zum Glück war auch dies leicht lösbar denn mit:
\newline 
- Input.acceleration.x
\newline
- Input.acceleration.z
\newline
- Input.acceleration.y
\newline
kann man in Unity schnell und einfach die Rotation des Smartphones bekommen.
Zusätzlich waren bei diesem Spiel auch sehr viele Fehler im zusammenhang mit der Nutzung der Network Streams, da es das erstes Spiel war und wir uns erst vertraut mit der Materie machen mussten.
